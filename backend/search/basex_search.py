"""Auxiliary functions to facilitate searching in BaseX."""

import lxml.etree

ALLOWED_DBNAME_CHARS = '!#$%&\'()+-=@[]^_`{}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcde' \
                       'fghijklmnopqrstuvwxyz0123456789.'


def check_xpath(xpath: str) -> bool:
    """Return True if a string is (only) a valid XPath, otherwise False."""
    try:
        lxml.etree.XPath(xpath)
    except lxml.etree.XPathError:
        return False
    else:
        return True


def check_db_name(db_name: str) -> bool:
    """Return True if a string may be (only) a valid BaseX database name,
    otherwise False."""
    return all(x in ALLOWED_DBNAME_CHARS for x in db_name)


def generate_xquery_search(basex_db: str, xpath: str) -> str:
    """Return XQuery string for use in BaseX to get all occurances
    of a given XPath in XML format in a given BaseX database."""
    if not check_db_name(basex_db) or not check_xpath(xpath):
        raise ValueError('Incorrect database or malformed XPath given')
    query = 'for $node in db:open("' + basex_db + '")/treebank' \
            + xpath + \
            ' let $tree := ($node/ancestor::alpino_ds)' \
            ' let $sentid := ($tree/@id)' \
            ' let $sentence := ($tree/sentence)' \
            ' let $ids := ($node//@id)' \
            ' let $indexs := (distinct-values($node//@index))' \
            ' let $indexed := ($tree//node[@index=$indexs])' \
            ' let $begins := (($node | $indexed)//@begin)' \
            ' let $beginlist := (distinct-values($begins))' \
            ' let $meta := ($tree/metadata/meta)' \
            ' return <match>{data($sentid)}||{data($sentence)}' \
            '||{string-join($ids, \'-\')}||' \
            '{string-join($beginlist, \'-\')}||{$node}||{$meta}' \
            '||</match>'
    # TODO: currently no support for grinded coprora and for variables.
    # Add returntb and variable_results from original implementation.
    return query


def generate_xquery_count(basex_db: str, xpath: str) -> str:
    """Return XQuery string for use in BaseX to get the count of all
    occurances of a given XPath in a given BaseX database."""
    if not check_db_name(basex_db) or not check_xpath(xpath):
        raise ValueError('Incorrect database or malformed XPath given')
    return 'count(for $node in db:open("{}")/treebank{} return $node)' \
        .format(basex_db, xpath)


def generate_xquery_showtree(basex_db: str, sentence_id: str) -> str:
    if not check_db_name(basex_db) or '"' in sentence_id:
        raise ValueError('Incorrect database or malformed sentence ID given')
    return 'db:open("' + basex_db + '")/treebank/alpino_ds[@id="' + \
        sentence_id + '"]'


def parse_search_result(result_str: str, component, database) -> list:
    """Parse the results returned by BaseX according to the searching
    XQuery generated by generate_xquery_search.

    Arguments:
      result_str (str): BaseX query result
      component (str): slug of current component
      database (str): slug of current database

    Returns:
      list: A list of matches represented by dictionaries

    Raises:
      ValueError: If result string cannot be parsed
    """
    matches = []
    i = 1
    for result in result_str.split('<match>'):
        result = result.strip()
        if result == '':
            continue
        if result.endswith('</match>'):
            result = result[:-len('</match>')]
        else:
            raise ValueError('Cannot parse XQuery result: <match> '
                             'is not closed in {}'.format(result))
        splitted = result.split('||')
        if len(splitted) != 7:
            raise ValueError('Cannot parse XQuery result: {}'.format(result))
        (sentid, sentence, ids, begins, xml_sentences, meta, _) = splitted
        # Make sentid-s unique by appending a match index (there may be
        # multiple matches per sentence)
        # TODO: can we change this to something more comprehensible?
        sentid = sentid + '+match=' + str(i)
        matches.append({
            'sentid': sentid,
            'sentence': sentence,
            'ids': ids,
            'begins': begins,
            'xml_sentences': xml_sentences,
            'meta': meta,
            'component': component,
            'database': database,
        })
        i += 1
    return matches
